# Лабараторная работа №1 Вариант 20
***Цель работы***: Разработать библиотеку для работы со структурой данных, а также тестовую программу и систему тестов, которые отображают работоспособность алгоритма
для заданного индивидуального задания.
***Задание***: Дерево сумм. Поиск суммы чисел на отрезке массива. Изменение всех чисел на отрезке массива на какое-то значение.
# Cписок используемых понятий:
_Дерево отрезков_ — это структура данных, которая позволяет эффективно (т.е. за асимптотику O(log n)) реализовать операции следующего вида: нахождение суммы элементов массива в заданном отрезке (a[l...r], где l и r поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива (т.е. разрешается присвоить всем элементам a[l...r] какое-либо значение, либо прибавить ко всем элементам массива какое-либо число).
_Дерево сумм_ — дерево, которое возвращает сумму всех элементов на отрезке.
# Описание алгоритмов
_Построение_:
Процесс построения дерева отрезков по заданному массиву a можно делать эффективно следующим образом, снизу вверх: сначала запишем значения элементов a[i] в соответствующие листья дерева, затем на основе них посчитаем значения для вершин предыдущего уровня как сумму значений в двух листьях, затем аналогичным образом посчитаем значения для ещё одного уровня, и т.д. Удобно описывать эту операцию рекурсивно: мы запускаем процедуру построения от корня дерева отрезков, а сама процедура построения, если её вызвали не от листа, вызывает себя от каждого из двух сыновей и суммирует вычисленные значения, а если её вызвали от листа — то просто записывает в себя значение этого элемента массива.

_Поиск суммы_:
На вход поступают два числа l и r, и мы должны за время O (log n) посчитать сумму чисел на отрезке a[l...r].
Для этого мы будем спускаться по построенному дереву отрезков, используя для подсчёта ответа посчитанные ранее суммы на каждой вершине дерева. Изначально мы встаём в корень дерева отрезков. Посмотрим, в какие из двух его сыновей попадает отрезок запроса [l.r] (напомним, что сыновья корня дерева отрезков — это отрезки [0...n/2] и [n/2+1...n-1]). Возможны два варианта: что отрезок [l...r] попадает только в одного сына корня, и что, наоборот, отрезок пересекается с обоими сыновьями.
Первый случай прост: просто перейдём в того сына, в котором лежит наш отрезок-запрос, и применим описываемый здесь алгоритм к текущей вершине.
Во втором же случае нам не остаётся других вариантов, кроме как перейти сначала в левого сына и посчитать ответ на запрос в нём, а затем — перейти в правого сына, посчитать в нём ответ и прибавить к нашему ответу. Иными словами, если левый сын представлял отрезок [l_1.r_1], а правый — отрезок [l_2...r_2] (заметим, что l_2 = r_1 + 1), то мы перейдём в левого сына с запросом [l...r_1], а в правого — с запросом [l_2...r].

_Изменение чисел_:
Изменение чисел можно реализовать как рекурсивную функцию: ей передаётся текущая вершина дерева отрезков, и эта функция выполняет рекурсивный вызов от одного из двух своих сыновей (от того, который содержит позицию i в своём отрезке), а после этого — пересчитывает значение суммы в текущей вершине точно таким же образом, как мы это делали при построении дерева отрезков (т.е. как сумма значений по обоим сыновьям текущей вершины).
# Результат тестирования
![image_2023-04-09_22-59-46](https://user-images.githubusercontent.com/116432612/230795424-a397d126-45b8-4ea8-b1ca-21b2c4fb406b.png)
# Используемые источники
https://drive.google.com/drive/folders/1U-r54LZD2m_yiPa1TuaaaS4t1hEWxa7q

https://e-maxx.ru/algo/segment_tree

https://www.youtube.com/watch?v=2_kZ-GQvK1M

https://www.youtube.com/watch?v=9o_i0zzxk1s
